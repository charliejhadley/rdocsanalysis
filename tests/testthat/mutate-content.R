% Generated by roxygen2: do not edit by hand\n% Please edit documentation in R/mutate.R\n\\name{mutate}\n\\alias{mutate}\n\\alias{mutate.data.frame}\n\\alias{transmute}\n\\title{Create, modify, and delete columns}\n\\usage{\nmutate(.data, ...)\n\n\\method{mutate}{data.frame}(\n  .data,\n  ...,\n  .keep = c(\"all\", \"used\", \"unused\", \"none\"),\n  .before = NULL,\n  .after = NULL\n)\n\ntransmute(.data, ...)\n}\n\\arguments{\n\\item{.data}{A data frame, data frame extension (e.g. a tibble), or a\nlazy data frame (e.g. from dbplyr or dtplyr). See \\emph{Methods}, below, for\nmore details.}\n\n\\item{...}{<\\code{\\link[=dplyr_data_masking]{data-masking}}> Name-value pairs.\nThe name gives the name of the column in the output.\n\nThe value can be:\n\\itemize{\n\\item A vector of length 1, which will be recycled to the correct length.\n\\item A vector the same length as the current group (or the whole data frame\nif ungrouped).\n\\item \\code{NULL}, to remove the column.\n\\item A data frame or tibble, to create multiple columns in the output.\n}}\n\n\\item{.keep}{\\Sexpr[results=rd]{lifecycle::badge(\"experimental\")}\nThis is an experimental argument that allows you to control which columns\nfrom \\code{.data} are retained in the output:\n\\itemize{\n\\item \\code{\"all\"}, the default, retains all variables.\n\\item \\code{\"used\"} keeps any variables used to make new variables; it's useful\nfor checking your work as it displays inputs and outputs side-by-side.\n\\item \\code{\"unused\"} keeps only existing variables \\strong{not} used to make new\nvariables.\n\\item \\code{\"none\"}, only keeps grouping keys (like \\code{\\link[=transmute]{transmute()}}).\n}\n\nGrouping variables are always kept, unconditional to \\code{.keep}.}\n\n\\item{.before, .after}{\\Sexpr[results=rd]{lifecycle::badge(\"experimental\")}\n<\\code{\\link[=dplyr_tidy_select]{tidy-select}}> Optionally, control where new columns\nshould appear (the default is to add to the right hand side). See\n\\code{\\link[=relocate]{relocate()}} for more details.}\n}\n\\value{\nAn object of the same type as \\code{.data}. The output has the following\nproperties:\n\\itemize{\n\\item Rows are not affected.\n\\item Existing columns will be preserved according to the \\code{.keep} argument.\nNew columns will be placed according to the \\code{.before} and \\code{.after}\narguments. If \\code{.keep = \"none\"} (as in \\code{transmute()}), the output order\nis determined only by \\code{...}, not the order of existing columns.\n\\item Columns given value \\code{NULL} will be removed\n\\item Groups will be recomputed if a grouping variable is mutated.\n\\item Data frame attributes are preserved.\n}\n}\n\\description{\n\\code{mutate()} adds new variables and preserves existing ones;\n\\code{transmute()} adds new variables and drops existing ones.\nNew variables overwrite existing variables of the same name.\nVariables can be removed by setting their value to \\code{NULL}.\n}\n\\section{Useful mutate functions}{\n\n\\itemize{\n\\item \\code{\\link{+}}, \\code{\\link{-}}, \\code{\\link[=log]{log()}}, etc., for their usual mathematical meanings\n\\item \\code{\\link[=lead]{lead()}}, \\code{\\link[=lag]{lag()}}\n\\item \\code{\\link[=dense_rank]{dense_rank()}}, \\code{\\link[=min_rank]{min_rank()}}, \\code{\\link[=percent_rank]{percent_rank()}}, \\code{\\link[=row_number]{row_number()}},\n\\code{\\link[=cume_dist]{cume_dist()}}, \\code{\\link[=ntile]{ntile()}}\n\\item \\code{\\link[=cumsum]{cumsum()}}, \\code{\\link[=cummean]{cummean()}}, \\code{\\link[=cummin]{cummin()}}, \\code{\\link[=cummax]{cummax()}}, \\code{\\link[=cumany]{cumany()}}, \\code{\\link[=cumall]{cumall()}}\n\\item \\code{\\link[=na_if]{na_if()}}, \\code{\\link[=coalesce]{coalesce()}}\n\\item \\code{\\link[=if_else]{if_else()}}, \\code{\\link[=recode]{recode()}}, \\code{\\link[=case_when]{case_when()}}\n}\n}\n\n\\section{Grouped tibbles}{\n\n\nBecause mutating expressions are computed within groups, they may\nyield different results on grouped tibbles. This will be the case\nas soon as an aggregating, lagging, or ranking function is\ninvolved. Compare this ungrouped mutate:\\preformatted{starwars \\%>\\%\n  select(name, mass, species) \\%>\\%\n  mutate(mass_norm = mass / mean(mass, na.rm = TRUE))\n}\n\nWith the grouped equivalent:\\preformatted{starwars \\%>\\%\n  select(name, mass, species) \\%>\\%\n  group_by(species) \\%>\\%\n  mutate(mass_norm = mass / mean(mass, na.rm = TRUE))\n}\n\nThe former normalises \\code{mass} by the global average whereas the\nlatter normalises by the averages within species levels.\n}\n\n\\section{Methods}{\n\nThese function are \\strong{generic}s, which means that packages can provide\nimplementations (methods) for other classes. See the documentation of\nindividual methods for extra arguments and differences in behaviour.\n\nMethods available in currently loaded packages:\n\\itemize{\n\\item \\code{mutate()}: \\Sexpr[stage=render,results=rd]{dplyr:::methods_rd(\"mutate\")}.\n\\item \\code{transmute()}: \\Sexpr[stage=render,results=rd]{dplyr:::methods_rd(\"transmute\")}.\n}\n}\n\n\\examples{\n# Newly created variables are available immediately\nstarwars \\%>\\%\n select(name, mass) \\%>\\%\n mutate(\n  mass2 = mass * 2,\n  mass2_squared = mass2 * mass2\n)\n\n# As well as adding new variables, you can use mutate() to\n# remove variables and modify existing variables.\nstarwars \\%>\\%\n select(name, height, mass, homeworld) \\%>\\%\n mutate(\n  mass = NULL,\n  height = height * 0.0328084 # convert to feet\n)\n\n# Use across() with mutate() to apply a transformation\n# to multiple columns in a tibble.\nstarwars \\%>\\%\n select(name, homeworld, species) \\%>\\%\n mutate(across(!name, as.factor))\n# see more in ?across\n\n# Window functions are useful for grouped mutates:\nstarwars \\%>\\%\n select(name, mass, homeworld) \\%>\\%\n group_by(homeworld) \\%>\\%\n mutate(rank = min_rank(desc(mass)))\n# see `vignette(\"window-functions\")` for more details\n\n# By default, new columns are placed on the far right.\n# Experimental: you can override with `.before` or `.after`\ndf <- tibble(x = 1, y = 2)\ndf \\%>\\% mutate(z = x + y)\ndf \\%>\\% mutate(z = x + y, .before = 1)\ndf \\%>\\% mutate(z = x + y, .after = x)\n\n# By default, mutate() keeps all columns from the input data.\n# Experimental: You can override with `.keep`\ndf <- tibble(x = 1, y = 2, a = \"a\", b = \"b\")\ndf \\%>\\% mutate(z = x + y, .keep = \"all\") # the default\ndf \\%>\\% mutate(z = x + y, .keep = \"used\")\ndf \\%>\\% mutate(z = x + y, .keep = \"unused\")\ndf \\%>\\% mutate(z = x + y, .keep = \"none\") # same as transmute()\n\n# Grouping ----------------------------------------\n# The mutate operation may yield different results on grouped\n# tibbles because the expressions are computed within groups.\n# The following normalises `mass` by the global average:\nstarwars \\%>\\%\n  select(name, mass, species) \\%>\\%\n  mutate(mass_norm = mass / mean(mass, na.rm = TRUE))\n\n# Whereas this normalises `mass` by the averages within species\n# levels:\nstarwars \\%>\\%\n  select(name, mass, species) \\%>\\%\n  group_by(species) \\%>\\%\n  mutate(mass_norm = mass / mean(mass, na.rm = TRUE))\n\n# Indirection ----------------------------------------\n# Refer to column names stored as strings with the `.data` pronoun:\nvars <- c(\"mass\", \"height\")\nmutate(starwars, prod = .data[[vars[[1]]]] * .data[[vars[[2]]]])\n# Learn more in ?dplyr_data_masking\n}\n\\seealso{\nOther single table verbs: \n\\code{\\link{arrange}()},\n\\code{\\link{filter}()},\n\\code{\\link{rename}()},\n\\code{\\link{select}()},\n\\code{\\link{slice}()},\n\\code{\\link{summarise}()}\n}\n\\concept{single table verbs}\n
